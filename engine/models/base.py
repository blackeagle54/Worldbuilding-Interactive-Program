"""
engine/models/base.py -- Base Pydantic models for the Worldbuilding Interactive Program.

Provides the foundational data models that all worldbuilding entities share.
These models handle the ``_meta`` envelope, common fields (name, id, notes),
and the interface for serialization / deserialization.

Every entity JSON file on disk has this shape::

    {
        "_meta": { "id": "...", "template_id": "...", ... },
        "name": "...",
        ...entity-specific fields...
    }

``WorldEntity`` captures the ``_meta`` envelope plus the common fields that
appear across virtually all templates.  Template-specific fields are handled
by dynamically generated models in ``engine.models.factory``.
"""

from __future__ import annotations

from datetime import datetime
from typing import Any

from pydantic import BaseModel, ConfigDict, Field, field_validator


class EntityMeta(BaseModel):
    """The ``_meta`` block stored in every entity JSON file.

    This block is managed by the engine -- users never edit it directly.
    It tracks provenance, status, and template linkage.
    """

    model_config = ConfigDict(
        extra="allow",
        populate_by_name=True,
    )

    id: str = Field(
        default="",
        description="Unique entity identifier (e.g. 'thorin-stormkeeper-a1b2').",
    )
    template_id: str = Field(
        default="",
        description="The $id of the JSON Schema template this entity was created from.",
    )
    entity_type: str = Field(
        default="",
        description="Entity type key matching the template registry (e.g. 'god', 'settlement').",
    )
    status: str = Field(
        default="draft",
        description="Lifecycle status: 'draft', 'canon', or 'archived'.",
    )
    file_path: str = Field(
        default="",
        description="Relative path from project root to this entity's JSON file.",
    )
    step_created: int | None = Field(
        default=None,
        description="The progression step number when this entity was first created.",
    )
    created_at: str = Field(
        default="",
        description="ISO 8601 timestamp of creation.",
    )
    updated_at: str = Field(
        default="",
        description="ISO 8601 timestamp of last modification.",
    )
    revision_number: int = Field(
        default=0,
        description="Current revision number (starts at 0).",
    )

    @field_validator("status")
    @classmethod
    def _validate_status(cls, v: str) -> str:
        allowed = {"draft", "canon", "archived", ""}
        if v and v not in allowed:
            raise ValueError(
                f"Status must be one of {sorted(allowed - {''})} "
                f"(got '{v}')."
            )
        return v


class WorldEntity(BaseModel):
    """Base model for all worldbuilding entities.

    Captures the ``_meta`` envelope and the handful of fields that appear
    in virtually every template (name, id, notes).  Template-specific
    fields are added dynamically by the model factory.

    The ``model_config`` allows extra fields so that template-specific
    properties pass through without error.  When a concrete model is
    generated by the factory, extra is set to ``"forbid"`` and all
    template fields are declared explicitly.
    """

    model_config = ConfigDict(
        extra="allow",
        populate_by_name=True,
    )

    meta: EntityMeta = Field(
        default_factory=EntityMeta,
        alias="_meta",
        description="Engine-managed metadata block.",
    )
    id: str = Field(
        default="",
        description="Top-level entity ID (mirrors _meta.id).",
    )
    name: str = Field(
        default="",
        description="Primary name of the entity.",
    )
    notes: str = Field(
        default="",
        description="Freeform notes.",
    )
    canon_claims: list[dict[str, Any]] = Field(
        default_factory=list,
        description="List of canon claims attached to this entity.",
    )

    @field_validator("name")
    @classmethod
    def _name_not_empty_if_present(cls, v: str) -> str:
        """Warn-level: name should not be purely whitespace."""
        if v and not v.strip():
            raise ValueError("Entity name must not be blank whitespace.")
        return v.strip() if v else v

    # ------------------------------------------------------------------
    # Convenience helpers
    # ------------------------------------------------------------------

    @property
    def entity_id(self) -> str:
        """Return the canonical entity ID (prefer _meta.id)."""
        return self.meta.id or self.id

    @property
    def entity_type(self) -> str:
        return self.meta.entity_type

    @property
    def meta_status(self) -> str:
        """The lifecycle status from ``_meta`` (draft / canon / archived).

        Named ``meta_status`` to avoid shadowing template-level ``status``
        fields (e.g. organization operational status).
        """
        return self.meta.status

    def to_file_dict(self) -> dict[str, Any]:
        """Serialize to the dict shape written to JSON entity files.

        Ensures ``_meta`` is emitted under its alias key and internal
        Pydantic fields (like ``meta``) are not leaked.
        """
        data = self.model_dump(by_alias=True, exclude_none=False)
        # Remove the un-aliased key if Pydantic emits both
        data.pop("meta", None)
        return data

    @classmethod
    def from_file_dict(cls, data: dict[str, Any]) -> "WorldEntity":
        """Construct from a dict as read from a JSON entity file."""
        return cls.model_validate(data)
